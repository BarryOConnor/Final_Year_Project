






Started logging.

<<<
Content-Length: 2998

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":2908,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 10\r\n#define NEO6MGPS_POWER_PIN 12\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10079

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}
<<<
";\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1814

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n       \r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(url) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 252

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":30,"character":8},"end":{"line":30,"character":21}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":40
>>>
Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 252

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":48,"character":0}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/37","percentage":2.7027027027027026,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 58

{"jsonrpc":"2.0","id":5,"method":"shutdown","params":null}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 2999

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":11144,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 11\r\n#define NEO6MGPS_POWER_PIN 12\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10079

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}
<<<
";\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1814

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n       \r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(url) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 253

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":35,"character":28},"end":{"line":35,"character":28}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":4
>>>
Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
0,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 252

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":48,"character":0}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/37","percentage":2.7027027027027026,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 181

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":11,"character":22}}}
>>>
Content-Length: 226

{"id":5,"result":{"contents":{"kind":"markdown","value":"### macro `DEBUG_BAUD`  \n\n---\n```cpp\n#define DEBUG_BAUD 115200\n```"},"range":{"start":{"line":20,"character":15},"end":{"line":20,"character":25}}},"jsonrpc":"2.0"}
<<<
Content-Length: 179

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":3,"character":8}}}
>>>
Content-Length: 225

{"id":6,"result":{"contents":{"kind":"markdown","value":"### macro `DEFAULT_BAUD`  \n\n---\n```cpp\n#define DEFAULT_BAUD 9600\n```"},"range":{"start":{"line":5,"character":8},"end":{"line":5,"character":20}}},"jsonrpc":"2.0"}
<<<
Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":6}}Content-Length: 180

{"jsonrpc":"2.0","id":7,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":7,"character":62}}}
>>>
Content-Length: 38

{"id":7,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 58

{"jsonrpc":"2.0","id":8,"method":"shutdown","params":null}
>>>
Content-Length: 38

{"id":8,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 2999

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":17044,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 11\r\n#define NEO6MGPS_POWER_PIN 12\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10079

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}
<<<
";\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1814

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n       \r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(url) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 253

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":35,"character":28},"end":{"line":35,"character":28}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":4
>>>
Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
0,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 252

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":48,"character":0}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/37","percentage":2.7027027027027026,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 76

{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}Content-Length: 179

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":8,"character":8}}}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":13,"character":9}}}
>>>
Content-Length: 322

{"id":6,"result":{"contents":{"kind":"markdown","value":"### instance-method `begin`  \n\n---\n→ `void`  \nParameters:  \n- `uint16_t baudrate`\n\n---\n```cpp\n// In WeatherSensor\npublic: void begin(uint16_t baudrate)\n```"},"range":{"start":{"line":22,"character":5},"end":{"line":22,"character":10}}},"jsonrpc":"2.0"}
<<<
Content-Length: 58

{"jsonrpc":"2.0","id":7,"method":"shutdown","params":null}
>>>
Content-Length: 38

{"id":7,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 2998

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":1464,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 11\r\n#define NEO6MGPS_POWER_PIN 12\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10079

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}
<<<
";\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1814

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n       \r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(url) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 253

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":35,"character":28},"end":{"line":35,"character":28}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":4
>>>
Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
0,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 252

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":48,"character":0}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/37","percentage":2.7027027027027026,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 179

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":33,"character":65}}}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":7,"character":69}}}
>>>
Content-Length: 38

{"id":6,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 255

{"jsonrpc":"2.0","id":7,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":10,"character":14},"end":{"line":10,"character":14}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":7,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":8,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":10,"character":2}}}
>>>
Content-Length: 38

{"id":8,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":11,"character":2}}}
>>>
Content-Length: 265

{"id":9,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":20,"character":2},"end":{"line":20,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 182

{"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":31,"character":15}}}
>>>
Content-Length: 39

{"id":10,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":2},"contentChanges":[{"range":{"start":{"line":33,"character":4},"end":{"line":33,"character":4}},"rangeLength":0,"text":"\r\n    "}]}}Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":2}}}
>>>
Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":1,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":1,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}
<<<
Content-Length: 380

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":3},"contentChanges":[{"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":4}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":33,"character":0},"end":{"line":33,"character":4}},"rangeLength":4,"text":""}]}}
>>>
Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":4},"contentChanges":[{"range":{"start":{"line":34,"character":5},"end":{"line":34,"character":5}},"rangeLength":0,"text":"e"}]}}Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":5},"contentChanges":[{"range":{"start":{"line":34,"character":6},"end":{"line":34,"character":6}},"rangeLength":0,"text":"r"}]}}Content-Length: 254

{"jsonrpc":"2.0","id":11,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":7},"end":{"line":34,"character":7}},"context":{"diagnostics":[]}}}Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":6},"contentChanges":[{"range":{"start":{"line":34,"character":7},"end":{"line":34,"character":7}},"rangeLength":0,"text":"i"}]}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":11}}Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":7},"contentChanges":[{"range":{"start":{"line":34,"character":8},"end":{"line":34,"character":8}},"rangeLength":0,"text":"a"}]}}Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":8},"contentChanges":[{"range":{"start":{"line":34,"character":9},"end":{"line":34,"character":9}},"rangeLength":0,"text":"l"}]}}Content-Length: 256

{"jsonrpc":"2.0","id":12,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":10},"end":{"line":34,"character":10}},"context":{"diagnostics":[]}}}Content-Length: 278

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":9},"contentChanges":[{"range":{"start":{"line":34,"character":10},"end":{"line":34,"character":10}},"rangeLength":0,"text":"."}]}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":12}}Content-Length: 238

{"jsonrpc":"2.0","id":13,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":34,"character":11},"context":{"triggerKind":2,"triggerCharacter":"."}}}
>>>
Content-Length: 37

{"id":11,"result":[],"jsonrpc":"2.0"}Content-Length: 37

{"id":12,"result":[],"jsonrpc":"2.0"}Content-Length: 6610

{"id":13,"result":{"isIncomplete":false,"items":[{"label":" available()","kind":2,"detail":"int","sortText":"3ee51eb8available","filterText":"available","insertText":"available()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"available()"}},{"label":" availableForWrite()","kind":2,"detail":"int","sortText":"3ee51eb8availableForWrite","filterText":"availableForWrite","insertText":"availableForWrite()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"availableForWrite()"}},{"label":" begin(…)","kind":2,"detail":"[2 overloads]","sortText":"3ee51eb8begin","filterText":"begin","insertText":"begin($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"begin($0)"}},{"label":" end()","kind":2,"detail":"void","sortText":"3ee51eb8end","filterText":"end","insertText":"end()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"end()"}},{"label":" flush()","kind":2,"detail":"void","sortText":"3ee51eb8flush","filterText":"flush","insertText":"flush()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"flush()"}},{"label":" peek()","kind":2,"detail":"int","sortText":"3ee51eb8peek","filterText":"peek","insertText":"peek()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"peek()"}},{"label":" read()","kind":2,"detail":"int","sortText":"3ee51eb8read","filterText":"read","insertText":"read()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"read()"}},{"label":" write(…)","kind":2,"detail":"[5 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"write($0)"}},{"label":" write(…)","kind":2,"detail":"[3 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"write($0)"}},{"label":" clearWriteError()","kind":2,"detail":"void","sortText":"3f651eb8clearWriteError","filterText":"clearWriteError","insertText":"clearWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"clearWriteError()"}},{"label":" find(…)","kind":2,"detail":"[5 overloads]","sortText":"3f651eb8find","filterText":"find","insertText":"find($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"find($0)"}},{"label":" findUntil(…)","kind":2,"detail":"[4 overloads]","sortText":"3f651eb8findUntil","filterText":"findUntil","insertText":"findUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"findUntil($0)"}},{"label":" getTimeout()","kind":2,"detail":"unsigned long","sortText":"3f651eb8getTimeout","filterText":"getTimeout","insertText":"getTimeout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"getTimeout()"}},{"label":" getWriteError()","kind":2,"detail":"int","sortText":"3f651eb8getWriteError","filterText":"getWriteError","insertText":"getWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"getWriteError()"}},{"label":" parseFloat(LookaheadMode lookahead = SKIP_ALL, char ignore = NO_IGNORE_CHAR)","kind":2,"detail":"float","sortText":"3f651eb8parseFloat","filterText":"parseFloat","insertText":"parseFloat()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"parseFloat()"}},{"label":" parseInt(LookaheadMode lookahead = SKIP_ALL, char ignore = NO_IGNORE_CHAR)","kind":2,"detail":"long","sortText":"3f651eb8parseInt","filterText":"parseInt","insertText":"parseInt()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"parseInt()"}},{"label":" print(…)","kind":2,"detail":"[11 overloads]","sortText":"3f651eb8print","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"print($0)"}},{"label":" println(…)","kind":2,"detail":"[12 overloads]","sortText":"3f651eb8println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"println($0)"}},{"label":" readBytes(…)","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytes","filterText":"readBytes","insertText":"readBytes($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"readBytes($0)"}},{"label":" readBytesUntil(…)","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytesUntil","filterText":"readBytesUntil","insertText":"readBytesUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"readBytesUntil($0)"}},{"label":" readString()","kind":2,"detail":"String","sortText":"3f651eb8readString","filterText":"readString","insertText":"readString()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"readString()"}},{"label":" readStringUntil(char terminator)","kind":2,"detail":"String","sortText":"3f651eb8readStringUntil","filterText":"readStringUntil","insertText":"readStringUntil(${1:char terminator})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"readStringUntil(${1:char terminator})"}},{"label":" setTimeout(unsigned long timeout)","kind":2,"detail":"void","sortText":"3f651eb8setTimeout","filterText":"setTimeout","insertText":"setTimeout(${1:unsigned long timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":43,"character":11},"end":{"line":43,"character":11}},"newText":"setTimeout(${1:unsigned long timeout})"}}]},"jsonrpc":"2.0"}Content-Length: 524

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":7}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'Ser'"},{"range":{"start":{"line":35,"character":6},"end":{"line":35,"character":7}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 328

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'ws' in 'HardwareSerial'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":9}}}Content-Length: 256

{"jsonrpc":"2.0","id":14,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":11}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":14,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":10},"contentChanges":[{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":11}},"rangeLength":0,"text":"p"}]}}
>>>
Content-Length: 529

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":12}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'p' in 'HardwareSerial'"},{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":11},"contentChanges":[{"range":{"start":{"line":34,"character":12},"end":{"line":34,"character":12}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 530

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":13}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pr' in 'HardwareSerial'"},{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":12},"contentChanges":[{"range":{"start":{"line":34,"character":13},"end":{"line":34,"character":13}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 531

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":14}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pri' in 'HardwareSerial'"},{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":13},"contentChanges":[{"range":{"start":{"line":34,"character":14},"end":{"line":34,"character":14}},"rangeLength":0,"text":"n"}]}}
>>>
Content-Length: 532

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":15}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prin' in 'HardwareSerial'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":14},"contentChanges":[{"range":{"start":{"line":34,"character":15},"end":{"line":34,"character":15}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 2326

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":16}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:65:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:66:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:67:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:68:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:69:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:70:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:71:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:72:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:73:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:74:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:75:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":15},"contentChanges":[{"range":{"start":{"line":34,"character":16},"end":{"line":34,"character":16}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 534

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":17}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'printl' in 'HardwareSerial'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 441

{"jsonrpc":"2.0","id":15,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":17},"end":{"line":34,"character":17}},"context":{"diagnostics":[{"range":{"start":{"line":34,"character":11},"end":{"line":34,"character":17}},"message":"No member named 'printl' in 'HardwareSerial'","severity":1,"code":"no_member","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":15,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":16},"contentChanges":[{"range":{"start":{"line":34,"character":17},"end":{"line":34,"character":17}},"rangeLength":0,"text":"n"}]}}
>>>
Content-Length: 2547

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:77:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:78:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:79:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:80:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:81:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:82:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:83:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:84:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:85:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:86:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:87:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:88:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 2454

{"jsonrpc":"2.0","id":16,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":18},"end":{"line":34,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":18}},"message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:77:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:78:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:79:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:80:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:81:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:82:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:83:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:84:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:85:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:86:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:87:12:\nnote: possible target for call\n\nC:\\Users\\Barry O'Connor\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.3\\cores\\arduino\\Print.h:88:12:\nnote: possible target for call","severity":1,"code":"bound_member_function","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":16,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 280

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":17},"contentChanges":[{"range":{"start":{"line":34,"character":18},"end":{"line":34,"character":18}},"rangeLength":0,"text":"()"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 261

{"jsonrpc":"2.0","id":17,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":34,"character":19},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 182

{"id":17,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 256

{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":18,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":17}}}Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":18},"contentChanges":[{"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":19}},"rangeLength":0,"text":"F"}]}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":2,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":2,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}Content-Length: 547

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":20}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'F' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 454

{"jsonrpc":"2.0","id":19,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":20},"end":{"line":34,"character":20}},"context":{"diagnostics":[{"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":20}},"message":"Use of undeclared identifier 'F' (fix available)","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":19,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":18}}}Content-Length: 280

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":19},"contentChanges":[{"range":{"start":{"line":34,"character":20},"end":{"line":34,"character":20}},"rangeLength":0,"text":"()"}]}}
>>>
Content-Length: 519

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":20}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 282

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":20},"contentChanges":[{"range":{"start":{"line":34,"character":21},"end":{"line":34,"character":21}},"rangeLength":0,"text":"\"\""}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 261

{"jsonrpc":"2.0","id":20,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":34,"character":22},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 182

{"id":20,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 256

{"jsonrpc":"2.0","id":21,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":22},"end":{"line":34,"character":22}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":21,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":20}}}Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":21},"contentChanges":[{"range":{"start":{"line":34,"character":22},"end":{"line":34,"character":22}},"rangeLength":0,"text":"R"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":22},"contentChanges":[{"range":{"start":{"line":34,"character":23},"end":{"line":34,"character":23}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":23},"contentChanges":[{"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":24}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":24},"contentChanges":[{"range":{"start":{"line":34,"character":25},"end":{"line":34,"character":25}},"rangeLength":0,"text":"d"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":25},"contentChanges":[{"range":{"start":{"line":34,"character":26},"end":{"line":34,"character":26}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":26},"contentChanges":[{"range":{"start":{"line":34,"character":27},"end":{"line":34,"character":27}},"rangeLength":0,"text":"n"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":27},"contentChanges":[{"range":{"start":{"line":34,"character":28},"end":{"line":34,"character":28}},"rangeLength":0,"text":"g"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":28},"contentChanges":[{"range":{"start":{"line":34,"character":29},"end":{"line":34,"character":29}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 256

{"jsonrpc":"2.0","id":22,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":30},"end":{"line":34,"character":30}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":22,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":28}}}Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":29},"contentChanges":[{"range":{"start":{"line":34,"character":30},"end":{"line":34,"character":30}},"rangeLength":0,"text":"S"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":30},"contentChanges":[{"range":{"start":{"line":34,"character":31},"end":{"line":34,"character":31}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":31},"contentChanges":[{"range":{"start":{"line":34,"character":32},"end":{"line":34,"character":32}},"rangeLength":0,"text":"n"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":32},"contentChanges":[{"range":{"start":{"line":34,"character":33},"end":{"line":34,"character":33}},"rangeLength":0,"text":"s"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":33},"contentChanges":[{"range":{"start":{"line":34,"character":34},"end":{"line":34,"character":34}},"rangeLength":0,"text":"o"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":34},"contentChanges":[{"range":{"start":{"line":34,"character":35},"end":{"line":34,"character":35}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":35},"contentChanges":[{"range":{"start":{"line":34,"character":36},"end":{"line":34,"character":36}},"rangeLength":0,"text":"s"}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 256

{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":37},"end":{"line":34,"character":37}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":23,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":35}}}Content-Length: 280

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":36},"contentChanges":[{"range":{"start":{"line":34,"character":37},"end":{"line":34,"character":38}},"rangeLength":1,"text":"\""}]}}Content-Length: 256

{"jsonrpc":"2.0","id":24,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":38},"end":{"line":34,"character":38}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":24,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":36}}}Content-Length: 278

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":37},"contentChanges":[{"range":{"start":{"line":34,"character":42},"end":{"line":34,"character":43}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 278

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":38},"contentChanges":[{"range":{"start":{"line":34,"character":41},"end":{"line":34,"character":42}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 278

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":39},"contentChanges":[{"range":{"start":{"line":34,"character":40},"end":{"line":34,"character":41}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 348

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[{"range":{"start":{"line":35,"character":4},"end":{"line":35,"character":6}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 256

{"jsonrpc":"2.0","id":25,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":40},"end":{"line":34,"character":40}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":25,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40},"contentChanges":[{"range":{"start":{"line":34,"character":40},"end":{"line":34,"character":40}},"rangeLength":0,"text":";"}]}}
>>>
Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 256

{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":41},"end":{"line":34,"character":41}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":26,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40}}}Content-Length: 181

{"jsonrpc":"2.0","id":27,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":32,"character":8}}}
>>>
Content-Length: 269

{"id":27,"result":{"contents":{"kind":"markdown","value":"### variable `result`  \n\n---\nType: `const char *`  \n\n---\n```cpp\n// In performAction\nconst char *result\n```"},"range":{"start":{"line":41,"character":4},"end":{"line":41,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40}}}Content-Length: 146

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","version":1}}}Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","version":1}}}Content-Length: 144

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","version":1}}}Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":1}}}
>>>
Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 182

{"jsonrpc":"2.0","id":28,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":24,"character":20}}}
>>>
Content-Length: 39

{"id":28,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 182

{"jsonrpc":"2.0","id":29,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"position":{"line":263,"character":3}}}
>>>
Content-Length: 39

{"id":29,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 192

{"jsonrpc":"2.0","id":30,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":23,"character":14}}}
>>>
Content-Length: 37

{"id":30,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 254

{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":23,"character":14},"end":{"line":23,"character":14}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":31,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 146

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","version":1}}}Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40}}}Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","version":1}}}Content-Length: 144

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","version":1}}}Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":1}}}Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40}}}Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","version":1}}}Content-Length: 146

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","version":1}}}Content-Length: 144

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","version":1}}}Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":1}}}Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40}}}Content-Length: 146

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","version":1}}}Content-Length: 144

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","version":1}}}Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","version":1}}}Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":1}}}Content-Length: 180

{"jsonrpc":"2.0","id":32,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":35,"character":28}}}
>>>
Content-Length: 39

{"id":32,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":33,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":35,"character":28}}}
>>>
Content-Length: 39

{"id":33,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 192

{"jsonrpc":"2.0","id":34,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":35,"character":28}}}
>>>
Content-Length: 37

{"id":34,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 254

{"jsonrpc":"2.0","id":35,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":35,"character":27},"end":{"line":35,"character":28}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":35,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":36,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":35,"character":26}}}
>>>
Content-Length: 39

{"id":36,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":2},"contentChanges":[{"range":{"start":{"line":35,"character":27},"end":{"line":35,"character":28}},"rangeLength":1,"text":"2"}]}}
>>>
Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 254

{"jsonrpc":"2.0","id":37,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":35,"character":28},"end":{"line":35,"character":28}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":37,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":2}}}Content-Length: 192

{"jsonrpc":"2.0","id":38,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":36,"character":29}}}
>>>
Content-Length: 37

{"id":38,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 254

{"jsonrpc":"2.0","id":39,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":36,"character":28},"end":{"line":36,"character":29}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":39,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 276

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":3},"contentChanges":[{"range":{"start":{"line":36,"character":28},"end":{"line":36,"character":29}},"rangeLength":1,"text":"3"}]}}
>>>
Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 254

{"jsonrpc":"2.0","id":40,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":36,"character":29},"end":{"line":36,"character":29}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":40,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":3}}}Content-Length: 151

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","version":40}}}Content-Length: 146

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","version":1}}}Content-Length: 150

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","version":1}}}Content-Length: 144

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","version":1}}}Content-Length: 148

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","version":3}}}Content-Length: 180

{"jsonrpc":"2.0","id":41,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":29,"character":23}}}
>>>
Content-Length: 39

{"id":41,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":42,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":31,"character":11}}}
>>>
Content-Length: 221

{"id":42,"result":{"contents":{"kind":"markdown","value":"### macro `GPS_TX_PIN`  \n\n---\n```cpp\n#define GPS_TX_PIN 6\n```"},"range":{"start":{"line":31,"character":8},"end":{"line":31,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 59

{"jsonrpc":"2.0","id":43,"method":"shutdown","params":null}
>>>
Content-Length: 39

{"id":43,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 2998

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":8852,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 12\r\n#define NEO6MGPS_POWER_PIN 13\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10078

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\";\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1932

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n\r\n    Serial.println(F(\"Reading Sensors\"));\r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"                        ) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 253

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":36,"character":29},"end":{"line":36,"character":29}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument"
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
:{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":40,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 255

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":41},"end":{"line":34,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 182

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":40,"character":100}}}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 180

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":24,"character":7}}}
>>>
Content-Length: 247

{"id":6,"result":{"contents":{"kind":"markdown","value":"### function `performAction`  \n\n---\n→ `void`  \n\n---\n```cpp\nvoid performAction()\n```"},"range":{"start":{"line":33,"character":4},"end":{"line":33,"character":17}}},"jsonrpc":"2.0"}
<<<
Content-Length: 181

{"jsonrpc":"2.0","id":7,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":39,"character":28}}}
>>>
Content-Length: 38

{"id":7,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 181

{"jsonrpc":"2.0","id":8,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"position":{"line":45,"character":96}}}
>>>
Content-Length: 38

{"id":8,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 58

{"jsonrpc":"2.0","id":9,"method":"shutdown","params":null}
>>>
Content-Length: 38

{"id":9,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 2998

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":8852,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 12\r\n#define NEO6MGPS_POWER_PIN 13\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10078

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\"
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}
<<<
;\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1932

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n\r\n    Serial.println(F(\"Reading Sensors\"));\r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"                        ) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 253

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":36,"character":29},"end":{"line":36,"character":29}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument"
>>>
Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
:{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":40,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 255

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":41},"end":{"line":34,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/37","percentage":2.7027027027027026,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 179

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":33,"character":28}}}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 179

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"position":{"line":33,"character":47}}}
>>>
Content-Length: 38

{"id":6,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 58

{"jsonrpc":"2.0","id":7,"method":"shutdown","params":null}
>>>
Content-Length: 38

{"id":7,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 2999

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":18412,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"i:\\NTU\\FYP\\WeatherSensor","rootUri":"file:///i%3A/NTU/FYP/WeatherSensor","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///i%3A/NTU/FYP/WeatherSensor","name":"WeatherSensor"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3166

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#ifndef WeatherSensor_h\r\n#define WeatherSensor_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <SPI.h>\r\n#include <Adafruit_Sensor.h>\r\n#include <Adafruit_BME280.h>\r\n#include <OneWire.h>\r\n#include <DallasTemperature.h>\r\n#include <EEPROM.h>\r\n#include <Wire.h>\r\n//#include <NeoSWSerial.h>\r\n#include \"WSSIM800L.h\"\r\n\r\n\r\n// DEFINITIONS\r\n// Analog Pins\r\n#define RAIN_SENSOR_PIN A0\r\n#define WIND_SPEED_PIN A3\r\n// Digital Pins\r\n#define DS18B20_PIN 2\r\n#define SIM_RESET_PIN 3\r\n#define SIM_SLEEP_PIN 4\r\n#define SIM_POWER_PIN 5\r\n#define GPS_TX_PIN 6\r\n#define GPS_RX_PIN 7\r\n#define SIM_RX_PIN 8 // AltSoftSerial needs 8 & 9 for sommunication\r\n#define SIM_TX_PIN 9\r\n#define SENSORS_POWER_PIN 12\r\n#define NEO6MGPS_POWER_PIN 13\r\n// other\r\n#define BME280_CHANNEL (0x76)\r\n\r\n// constants\r\n#define SEALEVELPRESSURE_HPA 1013.25\r\n#define FIVE_MINS 300\r\n#define SERIAL_MAX_LENGTH 40\r\n\r\n\r\n// slight adjustment needed for external temp as it is a little low when compared to a mercury thermometer\r\nconst float ext_adjustment = 1.5;\r\n\r\n\r\nstruct WeatherValues{\r\n  // arduino sprintf sunction doesn't include the %f identifier so we must use character representations of the float values\r\n  char temp_external[10] = \"0.00\";\r\n  char temp_internal[10] = \"0.00\";\r\n  char pressure[10] = \"0.00\";\r\n  char humidity[10] = \"0.00\";\r\n  uint16_t windspeed = 0;\r\n  uint16_t rain = 0;\r\n};\r\n\r\n\r\nclass WeatherSensor\r\n{\r\n  private: \r\n    uint16_t highest_wind = 0;\r\n    \r\n    // DS18B20\r\n    OneWire* DS18B20TempSensor;  \r\n    DallasTemperature* DS18B20ExternalTemp;\r\n    // BME280 \r\n    Adafruit_BME280 BME280; // I2C no softwareserial needed\r\n    //SIM800L\r\n    WSSIM800L* sim800l;\r\n    //NEO6MGPS\r\n    //NeoSWSerial* NEO6MGPS_Serial;  \r\n\r\n  public:\r\n    static const uint8_t ID_LENGTH = 8;\r\n    static const uint8_t MOBILE_LENGTH = 12;\r\n    struct WeatherValues currentValues;\r\n    WeatherSensor();\r\n    void begin(uint16_t baudrate);\r\n\r\n    bool validateRegData(const char* mobile, const char* id, const char* apn);\r\n    bool setupWeatherSensor(const char* mobile, const char* id, const char* apn);\r\n    const char* getMobile();\r\n    const char* getId();\r\n    const char* getApn();\r\n    void readSensors();\r\n\r\n    WeatherValues getCurrentValues();\r\n\r\n    void powerToSensor(bool power, uint8_t sensor);\r\n\r\n    // Windspeed\r\n    void updateWindspeed();\r\n    // EEPROM\r\n    const char* EEPROM_read(uint16_t offset, uint16_t = 0);\r\n    bool EEPROM_write(const char *content, uint16_t offset);\r\n    // SIM800L\r\n    bool SIM800L_SendSMS(const char *message);\r\n    const char* SIM800L_HTTPGet(const char* url);\r\n    // BME280\r\n    bool BME280_IsPresent();\r\n    // DS18B20\r\n    bool DS18B20_IsPresent();\r\n};\r\n#endif\r\n"}}}Content-Length: 10078

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","languageId":"cpp","version":1,"text":"/*\r\n  WeatherStation.h - Library for the automated weather station\r\n  N0813926\r\n*/\r\n#include \"WeatherSensor.h\"\r\n\r\n\r\nWeatherSensor::WeatherSensor() {\r\n  /*  Constructor for the class, empty by design - all of \r\n  *  the setup happens in the begin() method so that\r\n  *  the board can power up before the class initialises \r\n  *  pins otherwise issues happen\r\n  */ \r\n}\r\n\r\nvoid WeatherSensor::begin(uint16_t baudrate){\r\n  Serial.println(F(\"Starting...\"));\r\n  pinMode(SIM_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  pinMode(SIM_SLEEP_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_SLEEP_PIN);\r\n  pinMode(SIM_RESET_PIN, OUTPUT);\r\n  powerToSensor(false, SIM_RESET_PIN);\r\n  pinMode(SENSORS_POWER_PIN, OUTPUT);\r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n  pinMode(NEO6MGPS_POWER_PIN, OUTPUT);\r\n  powerToSensor(false, NEO6MGPS_POWER_PIN);\r\n\r\n  sim800l = new WSSIM800L(baudrate);\r\n\r\n  DS18B20TempSensor = new OneWire(DS18B20_PIN);  \r\n  DS18B20ExternalTemp = new DallasTemperature(DS18B20TempSensor);\r\n  //NEO6MGPS_Serial = new NeoSWSerial(GPS_RX_PIN, GPS_RX_PIN);\r\n  //NEO6MGPS_Serial->begin(DEFAULT_BAUD);\r\n  delay(1000);\r\n}\r\n\r\n\r\n\r\nbool WeatherSensor::validateRegData(const char* mobile, const char* id, const char* apn) {\r\n  /*  Validates registration data. \r\n  *  PARAMETERS\r\n  *  String mobile - contact mobile number (used for SMS)\r\n  *  String id - id for the device\r\n  *  String apn - network APN for the SIM card\r\n  *  RETURN\r\n  *  boolean indicating whether the operation was successful\r\n  */\r\n  if (strlen(mobile) != WeatherSensor::MOBILE_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- mobile number must be: ZZXXXXXXXXXXXX where ZZ is the country code and XXXXXXXXXXXX is the mobile number!\"));\r\n    #endif\r\n    return false;\r\n  } else if (strlen(id) != WeatherSensor::ID_LENGTH) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- ID must be 8 characters long\"));\r\n    #endif\r\n    return false;\r\n  } else if (apn == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- APN cannot be blank\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (int i = 0; i < WeatherSensor::MOBILE_LENGTH; i ++){\r\n    if (!isDigit(mobile[i])){\r\n      #if DEBUG\r\n        Serial.println(F(\"Weather Station:: ERROR:- mobile number can only contain digits!\"));\r\n      #endif\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool WeatherSensor::setupWeatherSensor(const char* mobile, const char* id, const char* apn) {\r\n  if (!validateRegData(mobile, id, apn)) {\r\n    return false;\r\n  }\r\n  \r\n  EEPROM_write(mobile, 0);\r\n  EEPROM_write(id, WeatherSensor::MOBILE_LENGTH);\r\n  EEPROM.update(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH, strlen(apn));\r\n  EEPROM_write(apn, WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1);\r\n  //write to eeprom and register on the website\r\n  return true;\r\n}\r\n\r\nconst char* WeatherSensor::getMobile(){\r\n  return EEPROM_read(0, MOBILE_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getId(){\r\n  return EEPROM_read(MOBILE_LENGTH, ID_LENGTH);\r\n}\r\n\r\nconst char* WeatherSensor::getApn(){\r\n  return EEPROM_read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH + 1, EEPROM.read(WeatherSensor::MOBILE_LENGTH + WeatherSensor::ID_LENGTH));\r\n}\r\n\r\nWeatherValues WeatherSensor::getCurrentValues(){\r\n  /*  returns an object with the current sensor values\r\n  */\r\n  return currentValues;\r\n}\r\n\r\nvoid WeatherSensor::readSensors(){\r\n  /*  turns on the power for sensors and reads data into \r\n  *  the currentValues struct\r\n  */\r\n\r\n  // turn on the power to the sensors \r\n  powerToSensor(true, SENSORS_POWER_PIN);\r\n\r\n  delay(1000); // delay for startup\r\n\r\n  // read data from BME280\r\n  if (BME280_IsPresent()){\r\n    dtostrf(BME280.readTemperature(), 4, 2, currentValues.temp_internal);    \r\n    dtostrf(BME280.readPressure() / 100, 4, 2, currentValues.pressure);\r\n    dtostrf(BME280.readHumidity(), 4, 2, currentValues.humidity); \r\n\r\n    // safe temperatures for the arduino are between -40 degrees C and 85 degrees C\r\n    if (BME280.readTemperature() > 75.00 || BME280.readTemperature() < -35.00) {\r\n      char sms_message[160];\r\n      sprintf(sms_message, \"Internal Temperature is %s degrees C. Damage to the electronics may occur above 85 degrees C or below -45 degrees C.\", currentValues.temp_internal);\r\n      SIM800L_SendSMS(sms_message);\r\n    }\r\n  }\r\n\r\n  // read data from DS18B20\r\n  if (DS18B20_IsPresent()){\r\n    DS18B20ExternalTemp->requestTemperatures();\r\n    dtostrf(DS18B20ExternalTemp->getTempCByIndex(0) + ext_adjustment, 4, 2, currentValues.temp_external);\r\n  }\r\n\r\n  // read the analog value from the rain sensor\r\n  currentValues.rain = analogRead(RAIN_SENSOR_PIN);\r\n\r\n  // transfer highest windspeed and reset to 0 for next interval\r\n  currentValues.windspeed = highest_wind;\r\n  highest_wind = 0;\r\n\r\n  #if DEBUG\r\n      Serial.print(F(\"Internal Temp: \"));\r\n      Serial.println(currentValues.temp_internal);      \r\n      Serial.print(F(\"Humidity: \"));\r\n      Serial.println(currentValues.humidity);\r\n      Serial.print(F(\"Pressure: \"));\r\n      Serial.println(currentValues.pressure);\r\n      Serial.print(F(\"External Temp: \"));\r\n      Serial.println(currentValues.temp_external);\r\n      Serial.print(F(\"Rain: \"));\r\n      Serial.println(currentValues.rain);\r\n      Serial.print(F(\"Wind: \"));\r\n      Serial.println(currentValues.windspeed);\r\n  #endif\r\n\r\n\r\n  // all done, turn the power off again\r\n  powerToSensor(false, SENSORS_POWER_PIN);  \r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::updateWindspeed(){\r\n  /*  Wind Speed changes a lot so this function is used to \r\n  *  store a highest value over the interval so that we can\r\n  *  record this rather than whatever the current reading is\r\n  */\r\n  uint16_t newWindSpeed = analogRead(WIND_SPEED_PIN);\r\n  if (newWindSpeed > highest_wind){\r\n    highest_wind = newWindSpeed;\r\n  }\r\n  return;\r\n}\r\n\r\nvoid WeatherSensor::powerToSensor(bool power, uint8_t sensor){\r\n  /*  Arduino pins can provide a voltage depending on whether\r\n  *  the output from the pin is HIGH or LOW allowing us to switch\r\n  *  the power on and off. \r\n  *  PARAMETERS\r\n  *  bool power - true = power on, false = power off\r\n  *  int sensor - the pin number of the sensor pin\r\n  */\r\n  \r\n  if(sensor == SIM_POWER_PIN || sensor == SIM_RESET_PIN){\r\n    // invert the signal for these signals\r\n    power = !power;\r\n  }\r\n\r\n  if(power){\r\n    // turn on power\r\n    digitalWrite(sensor, HIGH);\r\n  } else {\r\n    // turn off power\r\n    digitalWrite(sensor, LOW);\r\n  } \r\n      \r\n  return;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       EEPROM FUNCTIONS\r\n *       \r\n *  ========================== */\r\nconst char* WeatherSensor::EEPROM_read(uint16_t offset, uint16_t length) {\r\n  char returnValue[length+1];\r\n\r\n  // make sure that we're not reading past the end of the eeprom\r\n  if(offset + length > EEPROM.length()) {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot read past the end of memory!\"));\r\n    #endif\r\n    return \"\";\r\n  } else {\r\n    if (length == 0){\r\n      // needed for apn which isn't fixed length\r\n      length = EEPROM.read(offset);\r\n      offset++;\r\n    } \r\n    for (uint8_t address = 0; address < length; address++) {\r\n      returnValue[address] = char(EEPROM.read(offset + address));\r\n    }\r\n    returnValue[length] = '\\0';\r\n  }  \r\n  return strdup(&returnValue[0]);\r\n}\r\n\r\n\r\nbool WeatherSensor::EEPROM_write(const char *content, uint16_t offset) {\r\n  if(content == \"\") {\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station - ERROR:- nothing to write!\"));\r\n    #endif\r\n    return false;\r\n  } else if(offset + strlen(content) > EEPROM.length()) {\r\n    // make sure that we're not reading past the end of the eeprom\r\n    #if DEBUG\r\n      Serial.println(F(\"Weather Station:: ERROR:- cannot write past the end of memory!\"));\r\n    #endif\r\n    return false;\r\n  }\r\n\r\n  for (uint8_t address = 0; address < strlen(content); address++) {\r\n    EEPROM.update(offset + address, content[address]);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       SIM800L FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::SIM800L_SendSMS(const char* message) {\r\n  \r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  bool returnvalue = sim800l->sendSMS(getMobile(), message);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\nconst char* WeatherSensor::SIM800L_HTTPGet(const char* url) {\r\n\r\n  powerToSensor(true, SIM_POWER_PIN);\r\n  sim800l->reset();\r\n  const char* returnvalue = sim800l->httpGet(getApn(), url);\r\n  powerToSensor(false, SIM_POWER_PIN);\r\n\r\n  return returnvalue;\r\n}\r\n\r\n\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::BME280_IsPresent(){\r\n  if (!BME280.begin(BME280_CHANNEL)) {\r\n    Serial.println(F(\"BME280 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/*  ==========================\r\n *   \r\n *       BME280 FUNCTIONS\r\n *       \r\n *  ========================== */\r\n\r\n\r\nbool WeatherSensor::DS18B20_IsPresent(){\r\n  DS18B20ExternalTemp->begin();\r\n  if (DS18B20ExternalTemp->getDeviceCount() < 1){\r\n    Serial.println(F(\"DS18B20 sensor not found!\"));\r\n    return false;\r\n  }\r\n  return true;\r\n}  \r\n"}}}Content-Length: 1693

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","languageId":"cpp","version":1,"text":"#ifndef WSSIM800L_h\r\n#define WSSIM800L_h\r\n\r\n#ifndef DEBUG\r\n#define DEBUG true\r\n#endif\r\n\r\n#include <AltSoftSerial.h>\r\n\r\n#ifndef SIM_RESET_PIN\r\n#define SIM_RESET_PIN 3\r\n#endif\r\n\r\n//timer\r\n#define ONE_SECOND 1000000\r\n#define SHORT_SECONDS 1\r\n#define LONG_SECONDS 5\r\n#define DEFAULT_BUFFER_SIZE 200\r\n#define MAX_RETRIES 100\r\n#define NUM_RESPONSES 3\r\n#define TIMEOUT \"TIMED OUT\"\r\n#define HTTPREAD_COMMAND_LENGTH 14\r\n\r\nenum TimerType {BEGIN, ELAPSED, RENEW, SHORT, LONGER};\r\n\r\n\r\nclass WSSIM800L {\r\nprivate:\r\n    char buffer[DEFAULT_BUFFER_SIZE];\r\n    unsigned long maxTimeout;\r\n    AltSoftSerial* simSerial;\r\n    bool awaitingResponse = false;\r\n    uint8_t responseStatus = 0;\r\n    uint8_t responseLength = 0;\r\n\r\n    bool timer(TimerType type);\r\n    bool doCommand_P(const char* command, const char* expected = NULL, const char* parameter = NULL, int8_t retries = 0);\r\n    bool doCommand(const char* command, const char* expected = NULL, const char* parameter = NULL, bool hasQuotes = false, int8_t retries = 0);\r\n    void splitResponse();  \r\n    void sleep();\r\n    void wake();   \r\n\r\npublic:\r\n    WSSIM800L(int baudrate);\r\n    \r\n    bool reset();\r\n    bool isReady();  \r\n    void readSerialToBuffer();\r\n    void clearBuffer();    \r\n    bool checkResponse(const char* expected);\r\n    bool sendSMS(const char* mobile, const char* message);\r\n    const char* httpGet(const char* apn, const char* url);\r\n\r\n};\r\n#endif\r\n"}}}Content-Length: 10968

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","languageId":"cpp","version":1,"text":"#include \"WSSIM800L.h\"\r\n\r\n// AT COMMAND checks if the chip is ready\r\nconst char CMD_AT[] PROGMEM = \"AT\";\r\n// puts the chip into sleep mode\r\nconst char CMD_CSCLK2[] PROGMEM = \"AT+CSCLK=2\";\r\n// HTTP related\r\nconst char CMD_SAPBR_GPRS[] PROGMEM = \"AT+SAPBR=3,1,\\\"Contype\\\",\\\"GPRS\\\"\";\r\nconst char CMD_SAPBR_APN[] PROGMEM = \"AT+SAPBR=3,1,\\\"APN\\\",\\\"\";\r\nconst char CMD_SAPBR0[] PROGMEM = \"AT+SAPBR=0,1\"; \r\nconst char CMD_SAPBR1[] PROGMEM = \"AT+SAPBR=1,1\";\r\nconst char CMD_SAPBR2[] PROGMEM = \"AT+SAPBR=2,1\";\r\nconst char CMD_HTTPINIT[] PROGMEM = \"AT+HTTPINIT\";\r\nconst char CMD_HTTPPARA_CID[] PROGMEM = \"AT+HTTPPARA=\\\"CID\\\",1\";\r\nconst char CMD_HTTPPARA_URL[] PROGMEM = \"AT+HTTPPARA=\\\"URL\\\",\\\"\"; \r\nconst char CMD_HTTPACTION0[] PROGMEM = \"AT+HTTPACTION=0\";\r\nconst char CMD_HTTPREAD[] PROGMEM = \"AT+HTTPREAD=0,\";\r\n// SMS Related\r\nconst char CMD_CMGF[] PROGMEM = \"AT+CMGF=1\";\r\nconst char CMD_CMGS[] PROGMEM = \"AT+CMGS=\\\"+\";\r\nconst char CMD_CMGDA[] PROGMEM = \"AT+CMGDA=\\\"DEL ALL\\\"\";\r\n// responses\r\nconst char RESP_OK[] PROGMEM = \"OK\"
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}
<<<
;\r\nconst char RESP_ERROR[] PROGMEM = \"ERROR\";\r\nconst char RESP_GT[] PROGMEM = \">\";\r\nconst char RESP_CMGS[] PROGMEM = \"+CMGS:\";\r\nconst char RESP_HTTPREAD[] PROGMEM = \"+HTTPREAD:\";\r\n\r\n\r\nWSSIM800L::WSSIM800L(int baudrate) {\r\n\t/*\tConstructor for the class, empty by design - all of \r\n\t*\tthe setup happens in the begin() method so that\r\n\t*\tthe board can power up before the class initialises \r\n\t*\tpins otherwise issues happen\r\n\t*/ \r\n\tsimSerial = new AltSoftSerial;\r\n\tsimSerial->begin(baudrate);\r\n\ttimer(SHORT); // set the timer\r\n  sleep();\r\n\tpinMode(SIM_RESET_PIN, OUTPUT);\r\n}\r\n\r\n\r\nbool WSSIM800L::reset(){\r\n  // reset the SIM800L\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"WeatherStation:: Resetting SIM800L\"));\r\n\t#endif\r\n\r\n\t// Reset the device\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, LOW);\r\n\tdelay(500);\r\n\tdigitalWrite(SIM_RESET_PIN, HIGH);\r\n\tdelay(20000);\r\n  sleep();\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::isReady() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\treturn doCommand_P(CMD_AT, \"OK\", NULL, 50);\r\n}\r\n\r\n\r\n\r\nvoid WSSIM800L::sleep() {\t\r\n\t/*\tThe \"AT\" command is used to show the chip is ready for commands\r\n\t*/\r\n\t//doCommand_P(CMD_CSCLK2, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::wake() {\t\r\n\t/*\twhen waking from sleep, the first issued command is ignored and the following must occur within 50ms \r\n  so it is easier to simply send the first command without any verification and concentrate on the second\r\n\t*/\r\n  //simSerial->println(F(\"AT\"));\r\n\t//doCommand_P(CMD_AT, NULL);\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::timer(TimerType type) {\r\n\tstatic unsigned long timeStamp;\r\n\tunsigned long currentTime = micros();\r\n\r\n\tswitch (type) {\r\n\tcase ELAPSED:\r\n\t\tif (currentTime - timeStamp >= this->maxTimeout){ return true; }\r\n\t\tbreak;\r\n\tcase BEGIN:\r\n\tcase RENEW:\r\n\t\ttimeStamp = currentTime;\r\n\t\tbreak;\r\n\tcase SHORT:\r\n\t\tmaxTimeout =  1 * ONE_SECOND; // 1000 microseconds\r\n\t\tbreak;\r\n\tcase LONGER:\r\n\t\tmaxTimeout = 5 * ONE_SECOND; // 5000 microseconds\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\n\r\nvoid WSSIM800L::clearBuffer() {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clears the contents of the ioBuffer by filling it with zeroes.\r\n\tfor (uint16_t i = 0; i < DEFAULT_BUFFER_SIZE; i++) { \r\n\t\tbuffer[i] = 0; \r\n\t}\r\n}\r\n\r\n\r\nvoid WSSIM800L::readSerialToBuffer() {\r\n\tclearBuffer();\r\n\ttimer(BEGIN);\r\n\twhile (!simSerial->available()) {\r\n\t\tif (timer(ELAPSED)) {\r\n\t\t\tstrcat_P(buffer, TIMEOUT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tuint32_t buffCount = 0;\r\n\twhile (!timer(ELAPSED) || awaitingResponse) {\r\n\t\tif (simSerial->available()) {\r\n\t\t\tawaitingResponse = false;\r\n\t\t\ttimer(RENEW);\r\n\t\t\tif (buffCount <= DEFAULT_BUFFER_SIZE) {\r\n\t\t\t\tbuffer[buffCount] = simSerial->read();\r\n\t\t\t} else {\r\n\t\t\t\tsimSerial->read();\r\n\t\t\t}\r\n\t\t\tbuffCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::checkResponse(const char* expected){\r\n\treadSerialToBuffer();\r\n\tchar* comparison = strstr(buffer, expected);\r\n\r\n\tif (comparison != 0) { return true;\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand_P(const char* command, const char* expected, const char* parameter, int8_t retries) {\r\n\tchar commandBuffer[32];\r\n  strcpy_P(commandBuffer, command);\r\n  bool hasQuotes = false;\r\n\r\n  if (parameter != NULL && command != CMD_HTTPREAD){\r\n    hasQuotes = true;\r\n  }\r\n\r\n  return doCommand(commandBuffer, expected, parameter, hasQuotes, retries);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool WSSIM800L::doCommand(const char* command, const char* expected, const char* parameter, bool hasQuotes, int8_t retries) {\r\n\tbool success = false;\r\n\r\n\twhile (retries >= 0) {\r\n    if(parameter == NULL){\r\n      simSerial->println(command); // send the command to the chip\r\n    } else {\r\n      simSerial->print(command);\r\n      simSerial->print(parameter);\r\n      if(hasQuotes) {\r\n        simSerial->print(F(\"\\\"\"));\r\n      }\r\n      simSerial->println();\r\n    }\r\n\r\n\t\t\r\n\t\tif (expected == \"+CMGS:\") {\r\n\t\t\tsimSerial->write(0x1a);\r\n\t\t}\r\n\r\n\t\tsuccess = checkResponse(expected);  // check the response is as expected this also functions as a wait timer so\r\n\r\n\t\t#if DEBUG\r\n\t\t\t//log the command\r\n\t\t\tSerial.print(F(\"SIM800L Command: \"));\r\n      if(parameter == NULL){\r\n        Serial.println(command); // send the command to the chip\r\n      } else {\r\n        Serial.print(command);\r\n        Serial.print(parameter);\r\n        if(hasQuotes) {\r\n          Serial.print(F(\"\\\"\"));\r\n        }\r\n        Serial.println();\r\n      }\r\n\t\t\t// log the response\r\n\t\t\tSerial.print(F(\"SIM800L Command Response: \"));\r\n\t\t\tSerial.println(buffer);\r\n\t\t#endif\r\n\t\t\t\t\r\n\r\n\t\tif (success || expected == NULL) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tretries --;\t\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n\r\n\r\nvoid WSSIM800L::splitResponse(){\r\n\tchar* buffptr;\r\n  char current[20];\r\n\tbuffptr = strtok(buffer, \",\");\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseStatus = atoi(current);\r\n  strcpy(current, strtok(NULL, \",\"));\r\n\tresponseLength = atoi(current);\r\n}\r\n\r\n\r\nbool WSSIM800L::sendSMS(const char* mobile, const char* message) {\r\n  wake();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.println(F(\"SIM800L:: Attempting to send SMS...\"));\r\n\t#endif\r\n\r\n\ttimer(SHORT);\r\n\tuint8_t resetCount = 0;\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t// set the chip to SMS mode\r\n\tif (!doCommand_P(CMD_CMGF, \"OK\")) return false;\r\n\t\r\n\t// set the mobile number to send the SMS to\r\n\tif (!doCommand_P(CMD_CMGS, \">\", mobile)) return false;\t\r\n\t\r\n\t// the remaining commands need longer to execute so switch to a longer timer\r\n\ttimer(LONGER);\r\n\r\n\t//set the text content of the SMS and wait for verification\r\n\tif (!doCommand_P(message, \"+CMGS:\")) return false;\r\n\t\r\n\t//Clear the SMS from the SIM card so it won't get too full\r\n\tif (!doCommand_P(CMD_CMGDA, \"OK\")) return false;\r\n\r\n\t// set the timer back to short\r\n\ttimer(SHORT);\r\n\r\n  sleep();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst char* WSSIM800L::httpGet(const char* apn, const char* url) {\r\n\ttimer(SHORT);\r\n\r\n\tSerial.println(F(\"SIM800L:: Attempting to connect to website...\"));\r\n\r\n\t// wait for the chip to respond that it's ready to process commands\r\n\tisReady();\r\n\r\n\t/* SAPBR is the mobile provider information, so we need to first set the content type to GPRS */\r\n\tif (!doCommand_P(CMD_SAPBR_GPRS, \"OK\")) return NULL;\r\n\r\n\r\n\tif (!doCommand_P(CMD_SAPBR_APN, \"OK\", apn)) return NULL;\t\r\n\r\n\r\n\t// set the bearer profile to 1\r\n\tif (!doCommand_P(CMD_SAPBR1, NULL)) return NULL;\t\r\n\r\n\r\n\t// initialise HTTP action\r\n\tif (!doCommand_P(CMD_HTTPINIT, NULL)) return NULL;\t\r\n\r\n\r\n\t/* HTTPPARA is a set of parameters for a HTTP request so we must set several parameters before making that request */\r\n\t// set the CID parameter\r\n\tif (!doCommand_P(CMD_HTTPPARA_CID, \"OK\")) return NULL;\t\r\n\t\r\n\r\n\t// set the URL parameter\t\r\n\tif (!doCommand_P(CMD_HTTPPARA_URL, \"OK\", url)) return NULL;\t\r\n\r\n\r\n\t// HTTPACTION defines whether the request is a Get(0) POST(1) or Head(2)\r\n\tif (!doCommand_P(CMD_HTTPACTION0, \"OK\")) return NULL;\t\r\n\t\r\n\t// The response may take longer depending on network conditions so \r\n\t// set a flag to stop the system from timing out and set the longer timer duration\r\n\ttimer(LONGER);\r\n\tawaitingResponse = true;\r\n\treadSerialToBuffer();\r\n\r\n\t// the response contains the http status code and the length of the response\r\n\t// these are comma separated and so we need to split these into responseStatus and\r\n\t// responseLength variables for ease of use\r\n\tsplitResponse();\r\n\r\n\t#if DEBUG\r\n\t\tSerial.print(F(\"SIM800L:: Responded with status code: \"));\r\n\t\tSerial.println(responseStatus);\r\n\t\tSerial.println();\r\n\t#endif\r\n\t\r\n\t// if the HTTP status is 200 (\"OK\"), proceed with reading the response data\r\n\tif(responseStatus == 200){\r\n    char charBuffer[4];\r\n    itoa(responseLength, charBuffer, 10);\r\n\t\tif (!doCommand_P(CMD_HTTPREAD, \"+HTTPREAD:\", charBuffer)) return NULL;\t\r\n\r\n\t\t// reading the relevant positions for the reply from the buffer into a reply char array\r\n\t\tint startPoint = floor(log10(abs(responseLength))) + 1 + HTTPREAD_COMMAND_LENGTH;\r\n\t\tchar reply[responseLength];\r\n\t\tfor(int i = 1; i <= responseLength; i++ ) {\r\n\t\t\treply[i-1] = buffer[startPoint + i];\r\n\t\t\tif (i == responseLength) { reply[i] = '\\0';}\r\n\t\t}\r\n\t\t\r\n\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L Reply:: \"));\r\n\t\t\tSerial.println(reply);\r\n\t\t#endif\r\n\r\n    // close the GPRS connection and reset the timer to short\r\n    doCommand_P(CMD_SAPBR0, NULL);\r\n\t\ttimer(SHORT);\r\n\r\n\t\t// return the website content\r\n\t\treturn strdup(&reply[0]);\r\n\r\n\t} else {\r\n\t\t#if DEBUG\r\n\t\t\tSerial.print(F(\"SIM800L:: \"));\r\n\t\t\tSerial.print(F(\"HTTP Status code was:\"));\r\n\t\t\tSerial.println(responseStatus);\r\n\t\t#endif\r\n\t}\r\n\r\n  // close the GPRS connection and reset the timer to short\r\n\tdoCommand_P(CMD_SAPBR0, NULL);\r\n\ttimer(SHORT);\r\n\treturn NULL;\r\n}\r\n\r\n\r\n"}}}Content-Length: 1932

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino","languageId":"cpp","version":1,"text":"#include \"WeatherSensor.h\"\r\n\r\n#define DEBUG true\r\n#define DEFAULT_BAUD 9600\r\n#define DEBUG_BAUD 115200\r\n\r\nWeatherSensor ws;\r\nunsigned int reading_interval = 5 * 60 * 1000;      // number of minutes between data readings\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(DEBUG_BAUD);\r\n  while (!Serial) {}\r\n  ws.begin(DEFAULT_BAUD);\r\n  performAction(); \r\n}\r\n\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n   \r\n \r\n  // work out whether enough time has passed to take another set of readings\r\n  if (((currentMillis - previousMillis)) >= reading_interval) {\r\n    performAction();\r\n    // Use the snapshot to set track time until next event\r\n    previousMillis = currentMillis;\r\n   }\r\n}\r\n\r\nvoid performAction(){\r\n    char url[130];\r\n    const char* result;\r\n\r\n    Serial.println(F(\"Reading Sensors\"));\r\n    ws.readSensors();\r\n\r\n    WeatherValues current = ws.getCurrentValues();\r\n    \r\n    sprintf_P(url, PSTR(\"http://weather.barryoconnor.co.uk/p.php?d=%s&e=%s&i=%s&p=%s&h=%s&w=%u&r=%u\"), ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    //sprintf(url, data_mask, ws.getId(), current.temp_external, current.temp_internal, current.pressure, current.humidity, current.windspeed, current.rain);\r\n    #if DEBUG\r\n      Serial.println(F(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"));\r\n    #endif\r\n\r\n    if(ws.SIM800L_HTTPGet(\"http://weather.barryoconnor.co.uk/test.php?text=Barry\"                        ) == \"100\") {\r\n      ws.SIM800L_SendSMS(\"An attempt to store data from an unregistered device was made\");\r\n    };\r\n}\r\n"}}}Content-Length: 253

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h"},"range":{"start":{"line":36,"character":29},"end":{"line":36,"character":29}},"context":{"diagnostics":[]}}}Content-Length: 256

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp"},"range":{"start":{"line":275,"character":38},"end":{"line":283,"character":5}},"context":{"diagnostics":[]}}}Content-Length: 249

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument"
>>>
Content-Length: 143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 147

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.h","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}
<<<
:{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WSSIM800L.h"},"range":{"start":{"line":40,"character":16},"end":{"line":40,"character":16}},"context":{"diagnostics":[]}}}Content-Length: 255

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.ino"},"range":{"start":{"line":34,"character":41},"end":{"line":34,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 149

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///i%3A/NTU/FYP/WeatherSensor/WeatherSensor.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/37","percentage":5.405405405405405,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/37","percentage":8.108108108108109,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/37","percentage":10.81081081081081,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/37","percentage":13.513513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/37","percentage":16.216216216216218,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/37","percentage":18.91891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/37","percentage":21.62162162162162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/37","percentage":24.324324324324323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/37","percentage":27.027027027027028,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/37","percentage":29.72972972972973,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/37","percentage":32.432432432432435,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/37","percentage":35.13513513513514,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/37","percentage":37.83783783783784,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/37","percentage":40.54054054054054,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/37","percentage":43.24324324324324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/37","percentage":45.945945945945944,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/37","percentage":48.648648648648646,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/37","percentage":51.351351351351354,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/37","percentage":54.054054054054056,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/37","percentage":56.75675675675676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/37","percentage":59.45945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/37","percentage":62.16216216216216,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/37","percentage":64.86486486486487,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/37","percentage":67.56756756756756,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/37","percentage":70.27027027027027,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/37","percentage":72.97297297297297,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/37","percentage":75.67567567567568,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/37","percentage":78.37837837837837,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/37","percentage":81.08108108108108,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/37","percentage":83.78378378378379,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/37","percentage":86.48648648648648,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/37","percentage":89.1891891891892,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/37","percentage":91.89189189189189,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/37","percentage":94.5945945945946,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/37","percentage":97.29729729729729,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 58

{"jsonrpc":"2.0","id":5,"method":"shutdown","params":null}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}